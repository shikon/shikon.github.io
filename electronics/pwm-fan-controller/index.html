<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.21.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Creating a simple and cheap fan controller - Shiko</title>
<meta name="description" content="From need to idea to solution  After upgrading my computer with the new Ryzen 5800x series, the new motherboard did not include a header to connect my water temperature sensor. This lead the control of my fans to be limited to the temperature sensor inside the processor. This would be okay if I used regular processor cooling, which has  a small thermal mass and has good thermal conductivity.  However, in my case I have a water cooling where the temperature of the radiator depends on the water temperature and not so much on the current processor temperature. There is a huge delay in the order of minutes before the water heats up due to the large thermal mass it presents. Therefore the control that acts on the same timescale as workload increases (seconds) is an ill fit. Therefore I used the water temperature, which was read out on the previous motherboard. Unfortunately the motherboard that I got on sale did not have this.  Fortunately fans can easily be controlled by PWM hence this article will guide you to create a very simple and cheap PWM fan controller. But first what is PWM?  Pulse-Width Modulation (PWM) for fans  In order to control the fans the motherboard sends out signals that determine the speed fans should run at. The main reason to reduce the fan speed is to reduce the noise it makes. The lower speed is okay as under low processor load, the amount of heat that should be dissipated is low.  PWM is a signal and a way of communication which tells the fan at what speed it should run at. It is a digital signal and has a high (on) and low (off) level as shown here.    The frequency (f) of the PWM signal depends on the total time ($T_{on}+T_{off}$), \(f = \frac{1}{T_{on}+T_{off}}.\)  The speed of fan in percentage depends directly on the duty cycle (DT) in percentage, \(\mathrm{DT}=\frac{T_{on}}{T_{on}+T_{off}}.\) so if DT is 0.6 or 60% the speed of the fan will be 60% of its maximum speed.  Temperature of a thermistor  Okay we know how to create the signal but how do we know what speed the fans should run at. Depending on the amount of noise you allow at a certain water temperature, the water temperature is key. In order to find this out we need to translate the resistance of a thermistor back to a temperature. Typically these have a negative temperature coefficient, meaning the resistance decreases as the temperature increases. Since I do not know the model or make of my thermistor, I hoped  a commonly used model would be a good fit. The temperature ($T$) as function of the resistance ($R_T$) according to the Steinhart-Hart equation.  \(\frac{1}{T}=C_1+C_2\ln{R_T}+C_3(\ln{R_T})^3\) The other option was the $\beta-$equation which is an exponential relationship and can be extended to the Steinhart-Hart equation.  Requirements for the PWM fan controller     The PWM frequency of computer fans is typically 25 kHz but please check the data sheet.   Read temperature from a thermistor   The speed range for my fans was 30-100%   Tackling each problem 1-by-1  I separated the core functionalities of the fan controller into 3 parts.  1) Microprocessor choice and coding a PWM signal  In the beginning of this year I programmed a variable duty cycle on a Arduino nano. Achieving a PWM frequency of 1 MHz is not possible with the built in PWM functionality and neither is it variable at the resolution that I wanted (8-bit). In order to do this I went down one-level and set the registers of the timers. However, my past experience learnt me this took quite some development time. Therefore, this time I opted to use a different microcontroller where I could just use higher-level functions and generate the PWM signal according to my needs as simple as a few lines of code. I found a STM32F103C8T6 (STM32 black pill) lying around in my closet and found this library that had everything I needed.  2) Temperature readout by voltage divider  Just like in one of my past articles I used a voltage divider to find the thermistor resistance. Putting $R_T$ at the position of $R_2$, it can be found from the output voltage as, \(R_T = \frac{R_1}{V_{out}}\) With $R_1$ a chosen resistance in my case 4.7 k$\Omega$. Since the thermistor model is basically a linearization that is accurate in a certain range, I chose $R_1$  such that it is similar to $R_T$ during computer idle.  In order to find the coefficients you would take measurements of $R_T$ at for example three different temperatures. Since my sensor was already mounted in the system and it doesn’t have to be very accurate I took a random measurement found on the internet for the same kind of thermistor that I had which is a 10 k$\Omega$-thermistor. Plugged 3-points into this tool for 25, 50 and 70 $^\circ$ C, which is the range I expect the water to be in and thus the sensor to be exposed to.  3) Defining different speed ramp up ranged depending on temperature  In order to create a silent system you want initially the fan speed to be low at low temperatures and high at high temperature. But what is low and and what is high? Since my fans can not be run below 30%, this was the lower limit (this is not exactly true but I will discuss this later). In order for heat transfer to occur via convection there needs to be a temperature difference between the radiator ( I assume it equal to it water temperature) and the environment. My room is typically below  30$^\circ$C therefore up to let say a water temperature of 40$^\circ$C the fans run in the lowest setting and then they should gradually increase. This is in my code split into 2 different ramps, in order to keep the system more quiet and when a lot of heat is dumped into the water cooling, the fans will still go to 100%. This point was chosen to be 70$^\circ$C, because the tubes start to melt at 74$^\circ$C according to the manufacturer.  Extra) true 0% PWM  Sometimes you might want to go lower than 30% or even turn it off to save power but also to prevent noise. I did not do this as this extra step, requires a lot of effort for very little gain in my case. However should you need to do it. This can be achieved by setting the PWM duty-cycle to 0% in the case when water temperature is already below what you like, in my code 40$^\circ$C. Then you would switch off a MOSFET thus set the gate voltage to low or 0 V and when it s above  40$^\circ$C you would turn it on. The MOSFET should then connect between your black wire (anode) from your fan and the anode of your power supply.  Connections  Since the connection diagram is quite simple I do it in words. The thermistor has 2 pins (there is no polarity) and should be connected as in the voltage divider, 1 to ground and 1 to $R_1$.  Finally the PWM signal is output at pin PA8 and this should go to the PWM pin as follows,    Lastly power for the microcontroller can be supplied over the micro-USB.  The final code  #include &lt;Arduino.h&gt; #define inLED PB12 #define PWMpin PA8 #define SERIAL_PORT Serial1 #define f_PWM 25000 #define PWMstatic 30 #define SAMPLES 100  HardwareSerial Serial1(PA_10, PA_9); //Thermistor const #define T_waterpin PA7 int Vo; float Rchosen = 4582; float logR2, R2, T; float c1 = 1.133027435e-03, c2 = 2.334426745e-04, c3 = 0.9074747924e-07;  //code variables float Ttest; int PWMdynamic = 0, PWMold= 0; int  i, Vs; bool paused = 0;  //init specifics of the hardware timer and which effectively pin TIM_TypeDef *Instance = (TIM_TypeDef *)pinmap_peripheral(digitalPinToPinName(PWMpin), PinMap_PWM); uint32_t channel = STM_PIN_CHANNEL(pinmap_function(digitalPinToPinName(PWMpin), PinMap_PWM)); //Timer object init with previous intel HardwareTimer *MyTim = new HardwareTimer(Instance);   // no need to configure pin, it will be done by HardwareTimer configuration  float reading_to_temp(int number, int R1){   int temp;   R2 = R1 / (1023.0 / (float)number - 1.0);   logR2 = log(R2);   temp = (1.0 / (c1 + c2*logR2 + c3*logR2*logR2*logR2));   temp = temp - 273.15;   return temp; }  void setup() {   pinMode(inLED, OUTPUT);   digitalWrite(inLED, LOW);   MyTim-&gt;setPWM(channel, PWMpin, f_PWM, PWMstatic);            // 5 Hertz, 10% dutycycle }  void loop() {   //improve averaging of analogread by oversampling because required speed is only ~ Hz.   Vs = 0;   for(i = 0; i &lt; SAMPLES; i++){     Vs = Vs + analogRead(T_waterpin);   }   Vo = Vs / SAMPLES;   T = reading_to_temp(Vo, Rchosen);   Ttest = T;   if(Ttest &lt;=40){     PWMdynamic = 30;     //MyTim-&gt;pause();     paused = 1;   }   else if(paused){     paused = 0;     //MyTim-&gt;resume();   }   if(Ttest &gt; 40 &amp;&amp; Ttest &lt;= 60){     PWMdynamic = 30 + 25 * (Ttest - 40) / 20;   }   else if(Ttest &gt; 60 &amp;&amp; Ttest &lt;= 70){     PWMdynamic = 55 + 45 * (Ttest - 60) / 10;   }   else if(Ttest &gt; 70){     PWMdynamic = 100;   }   //hysteresis to keep number of updates small and prevent oscillatory behaviour.   if( abs(PWMdynamic - PWMold) &gt; 3){     MyTim-&gt;setCaptureCompare(channel, PWMdynamic, PERCENT_COMPARE_FORMAT);     PWMold = PWMdynamic;   } }   Final cost                 Component       Cost ($\euro$)                       Resistor 4k7       0.01/free                 Black pill (STM32F1)       3.63           Any other STM32 series MCU would work as long as it is supported by the library. It seems my version of black pill is end of life, the new version would work also. Please be careful for the pin assignment, which could be different.">


  <meta name="author" content="Lan Hu">
  
  <meta property="article:author" content="Lan Hu">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Shiko">
<meta property="og:title" content="Creating a simple and cheap fan controller">
<meta property="og:url" content="https://shiko.nl/electronics/pwm-fan-controller/">


  <meta property="og:description" content="From need to idea to solution  After upgrading my computer with the new Ryzen 5800x series, the new motherboard did not include a header to connect my water temperature sensor. This lead the control of my fans to be limited to the temperature sensor inside the processor. This would be okay if I used regular processor cooling, which has  a small thermal mass and has good thermal conductivity.  However, in my case I have a water cooling where the temperature of the radiator depends on the water temperature and not so much on the current processor temperature. There is a huge delay in the order of minutes before the water heats up due to the large thermal mass it presents. Therefore the control that acts on the same timescale as workload increases (seconds) is an ill fit. Therefore I used the water temperature, which was read out on the previous motherboard. Unfortunately the motherboard that I got on sale did not have this.  Fortunately fans can easily be controlled by PWM hence this article will guide you to create a very simple and cheap PWM fan controller. But first what is PWM?  Pulse-Width Modulation (PWM) for fans  In order to control the fans the motherboard sends out signals that determine the speed fans should run at. The main reason to reduce the fan speed is to reduce the noise it makes. The lower speed is okay as under low processor load, the amount of heat that should be dissipated is low.  PWM is a signal and a way of communication which tells the fan at what speed it should run at. It is a digital signal and has a high (on) and low (off) level as shown here.    The frequency (f) of the PWM signal depends on the total time ($T_{on}+T_{off}$), \(f = \frac{1}{T_{on}+T_{off}}.\)  The speed of fan in percentage depends directly on the duty cycle (DT) in percentage, \(\mathrm{DT}=\frac{T_{on}}{T_{on}+T_{off}}.\) so if DT is 0.6 or 60% the speed of the fan will be 60% of its maximum speed.  Temperature of a thermistor  Okay we know how to create the signal but how do we know what speed the fans should run at. Depending on the amount of noise you allow at a certain water temperature, the water temperature is key. In order to find this out we need to translate the resistance of a thermistor back to a temperature. Typically these have a negative temperature coefficient, meaning the resistance decreases as the temperature increases. Since I do not know the model or make of my thermistor, I hoped  a commonly used model would be a good fit. The temperature ($T$) as function of the resistance ($R_T$) according to the Steinhart-Hart equation.  \(\frac{1}{T}=C_1+C_2\ln{R_T}+C_3(\ln{R_T})^3\) The other option was the $\beta-$equation which is an exponential relationship and can be extended to the Steinhart-Hart equation.  Requirements for the PWM fan controller     The PWM frequency of computer fans is typically 25 kHz but please check the data sheet.   Read temperature from a thermistor   The speed range for my fans was 30-100%   Tackling each problem 1-by-1  I separated the core functionalities of the fan controller into 3 parts.  1) Microprocessor choice and coding a PWM signal  In the beginning of this year I programmed a variable duty cycle on a Arduino nano. Achieving a PWM frequency of 1 MHz is not possible with the built in PWM functionality and neither is it variable at the resolution that I wanted (8-bit). In order to do this I went down one-level and set the registers of the timers. However, my past experience learnt me this took quite some development time. Therefore, this time I opted to use a different microcontroller where I could just use higher-level functions and generate the PWM signal according to my needs as simple as a few lines of code. I found a STM32F103C8T6 (STM32 black pill) lying around in my closet and found this library that had everything I needed.  2) Temperature readout by voltage divider  Just like in one of my past articles I used a voltage divider to find the thermistor resistance. Putting $R_T$ at the position of $R_2$, it can be found from the output voltage as, \(R_T = \frac{R_1}{V_{out}}\) With $R_1$ a chosen resistance in my case 4.7 k$\Omega$. Since the thermistor model is basically a linearization that is accurate in a certain range, I chose $R_1$  such that it is similar to $R_T$ during computer idle.  In order to find the coefficients you would take measurements of $R_T$ at for example three different temperatures. Since my sensor was already mounted in the system and it doesn’t have to be very accurate I took a random measurement found on the internet for the same kind of thermistor that I had which is a 10 k$\Omega$-thermistor. Plugged 3-points into this tool for 25, 50 and 70 $^\circ$ C, which is the range I expect the water to be in and thus the sensor to be exposed to.  3) Defining different speed ramp up ranged depending on temperature  In order to create a silent system you want initially the fan speed to be low at low temperatures and high at high temperature. But what is low and and what is high? Since my fans can not be run below 30%, this was the lower limit (this is not exactly true but I will discuss this later). In order for heat transfer to occur via convection there needs to be a temperature difference between the radiator ( I assume it equal to it water temperature) and the environment. My room is typically below  30$^\circ$C therefore up to let say a water temperature of 40$^\circ$C the fans run in the lowest setting and then they should gradually increase. This is in my code split into 2 different ramps, in order to keep the system more quiet and when a lot of heat is dumped into the water cooling, the fans will still go to 100%. This point was chosen to be 70$^\circ$C, because the tubes start to melt at 74$^\circ$C according to the manufacturer.  Extra) true 0% PWM  Sometimes you might want to go lower than 30% or even turn it off to save power but also to prevent noise. I did not do this as this extra step, requires a lot of effort for very little gain in my case. However should you need to do it. This can be achieved by setting the PWM duty-cycle to 0% in the case when water temperature is already below what you like, in my code 40$^\circ$C. Then you would switch off a MOSFET thus set the gate voltage to low or 0 V and when it s above  40$^\circ$C you would turn it on. The MOSFET should then connect between your black wire (anode) from your fan and the anode of your power supply.  Connections  Since the connection diagram is quite simple I do it in words. The thermistor has 2 pins (there is no polarity) and should be connected as in the voltage divider, 1 to ground and 1 to $R_1$.  Finally the PWM signal is output at pin PA8 and this should go to the PWM pin as follows,    Lastly power for the microcontroller can be supplied over the micro-USB.  The final code  #include &lt;Arduino.h&gt; #define inLED PB12 #define PWMpin PA8 #define SERIAL_PORT Serial1 #define f_PWM 25000 #define PWMstatic 30 #define SAMPLES 100  HardwareSerial Serial1(PA_10, PA_9); //Thermistor const #define T_waterpin PA7 int Vo; float Rchosen = 4582; float logR2, R2, T; float c1 = 1.133027435e-03, c2 = 2.334426745e-04, c3 = 0.9074747924e-07;  //code variables float Ttest; int PWMdynamic = 0, PWMold= 0; int  i, Vs; bool paused = 0;  //init specifics of the hardware timer and which effectively pin TIM_TypeDef *Instance = (TIM_TypeDef *)pinmap_peripheral(digitalPinToPinName(PWMpin), PinMap_PWM); uint32_t channel = STM_PIN_CHANNEL(pinmap_function(digitalPinToPinName(PWMpin), PinMap_PWM)); //Timer object init with previous intel HardwareTimer *MyTim = new HardwareTimer(Instance);   // no need to configure pin, it will be done by HardwareTimer configuration  float reading_to_temp(int number, int R1){   int temp;   R2 = R1 / (1023.0 / (float)number - 1.0);   logR2 = log(R2);   temp = (1.0 / (c1 + c2*logR2 + c3*logR2*logR2*logR2));   temp = temp - 273.15;   return temp; }  void setup() {   pinMode(inLED, OUTPUT);   digitalWrite(inLED, LOW);   MyTim-&gt;setPWM(channel, PWMpin, f_PWM, PWMstatic);            // 5 Hertz, 10% dutycycle }  void loop() {   //improve averaging of analogread by oversampling because required speed is only ~ Hz.   Vs = 0;   for(i = 0; i &lt; SAMPLES; i++){     Vs = Vs + analogRead(T_waterpin);   }   Vo = Vs / SAMPLES;   T = reading_to_temp(Vo, Rchosen);   Ttest = T;   if(Ttest &lt;=40){     PWMdynamic = 30;     //MyTim-&gt;pause();     paused = 1;   }   else if(paused){     paused = 0;     //MyTim-&gt;resume();   }   if(Ttest &gt; 40 &amp;&amp; Ttest &lt;= 60){     PWMdynamic = 30 + 25 * (Ttest - 40) / 20;   }   else if(Ttest &gt; 60 &amp;&amp; Ttest &lt;= 70){     PWMdynamic = 55 + 45 * (Ttest - 60) / 10;   }   else if(Ttest &gt; 70){     PWMdynamic = 100;   }   //hysteresis to keep number of updates small and prevent oscillatory behaviour.   if( abs(PWMdynamic - PWMold) &gt; 3){     MyTim-&gt;setCaptureCompare(channel, PWMdynamic, PERCENT_COMPARE_FORMAT);     PWMold = PWMdynamic;   } }   Final cost                 Component       Cost ($\euro$)                       Resistor 4k7       0.01/free                 Black pill (STM32F1)       3.63           Any other STM32 series MCU would work as long as it is supported by the library. It seems my version of black pill is end of life, the new version would work also. Please be careful for the pin assignment, which could be different.">



  <meta property="og:image" content="https://raw.githubusercontent.com/shikon/cloudimg/master/typora/photo_2021-08-27_16-51-22.jpg">



  <meta name="twitter:site" content="@mmistakes">
  <meta name="twitter:title" content="Creating a simple and cheap fan controller">
  <meta name="twitter:description" content="From need to idea to solution  After upgrading my computer with the new Ryzen 5800x series, the new motherboard did not include a header to connect my water temperature sensor. This lead the control of my fans to be limited to the temperature sensor inside the processor. This would be okay if I used regular processor cooling, which has  a small thermal mass and has good thermal conductivity.  However, in my case I have a water cooling where the temperature of the radiator depends on the water temperature and not so much on the current processor temperature. There is a huge delay in the order of minutes before the water heats up due to the large thermal mass it presents. Therefore the control that acts on the same timescale as workload increases (seconds) is an ill fit. Therefore I used the water temperature, which was read out on the previous motherboard. Unfortunately the motherboard that I got on sale did not have this.  Fortunately fans can easily be controlled by PWM hence this article will guide you to create a very simple and cheap PWM fan controller. But first what is PWM?  Pulse-Width Modulation (PWM) for fans  In order to control the fans the motherboard sends out signals that determine the speed fans should run at. The main reason to reduce the fan speed is to reduce the noise it makes. The lower speed is okay as under low processor load, the amount of heat that should be dissipated is low.  PWM is a signal and a way of communication which tells the fan at what speed it should run at. It is a digital signal and has a high (on) and low (off) level as shown here.    The frequency (f) of the PWM signal depends on the total time ($T_{on}+T_{off}$), \(f = \frac{1}{T_{on}+T_{off}}.\)  The speed of fan in percentage depends directly on the duty cycle (DT) in percentage, \(\mathrm{DT}=\frac{T_{on}}{T_{on}+T_{off}}.\) so if DT is 0.6 or 60% the speed of the fan will be 60% of its maximum speed.  Temperature of a thermistor  Okay we know how to create the signal but how do we know what speed the fans should run at. Depending on the amount of noise you allow at a certain water temperature, the water temperature is key. In order to find this out we need to translate the resistance of a thermistor back to a temperature. Typically these have a negative temperature coefficient, meaning the resistance decreases as the temperature increases. Since I do not know the model or make of my thermistor, I hoped  a commonly used model would be a good fit. The temperature ($T$) as function of the resistance ($R_T$) according to the Steinhart-Hart equation.  \(\frac{1}{T}=C_1+C_2\ln{R_T}+C_3(\ln{R_T})^3\) The other option was the $\beta-$equation which is an exponential relationship and can be extended to the Steinhart-Hart equation.  Requirements for the PWM fan controller     The PWM frequency of computer fans is typically 25 kHz but please check the data sheet.   Read temperature from a thermistor   The speed range for my fans was 30-100%   Tackling each problem 1-by-1  I separated the core functionalities of the fan controller into 3 parts.  1) Microprocessor choice and coding a PWM signal  In the beginning of this year I programmed a variable duty cycle on a Arduino nano. Achieving a PWM frequency of 1 MHz is not possible with the built in PWM functionality and neither is it variable at the resolution that I wanted (8-bit). In order to do this I went down one-level and set the registers of the timers. However, my past experience learnt me this took quite some development time. Therefore, this time I opted to use a different microcontroller where I could just use higher-level functions and generate the PWM signal according to my needs as simple as a few lines of code. I found a STM32F103C8T6 (STM32 black pill) lying around in my closet and found this library that had everything I needed.  2) Temperature readout by voltage divider  Just like in one of my past articles I used a voltage divider to find the thermistor resistance. Putting $R_T$ at the position of $R_2$, it can be found from the output voltage as, \(R_T = \frac{R_1}{V_{out}}\) With $R_1$ a chosen resistance in my case 4.7 k$\Omega$. Since the thermistor model is basically a linearization that is accurate in a certain range, I chose $R_1$  such that it is similar to $R_T$ during computer idle.  In order to find the coefficients you would take measurements of $R_T$ at for example three different temperatures. Since my sensor was already mounted in the system and it doesn’t have to be very accurate I took a random measurement found on the internet for the same kind of thermistor that I had which is a 10 k$\Omega$-thermistor. Plugged 3-points into this tool for 25, 50 and 70 $^\circ$ C, which is the range I expect the water to be in and thus the sensor to be exposed to.  3) Defining different speed ramp up ranged depending on temperature  In order to create a silent system you want initially the fan speed to be low at low temperatures and high at high temperature. But what is low and and what is high? Since my fans can not be run below 30%, this was the lower limit (this is not exactly true but I will discuss this later). In order for heat transfer to occur via convection there needs to be a temperature difference between the radiator ( I assume it equal to it water temperature) and the environment. My room is typically below  30$^\circ$C therefore up to let say a water temperature of 40$^\circ$C the fans run in the lowest setting and then they should gradually increase. This is in my code split into 2 different ramps, in order to keep the system more quiet and when a lot of heat is dumped into the water cooling, the fans will still go to 100%. This point was chosen to be 70$^\circ$C, because the tubes start to melt at 74$^\circ$C according to the manufacturer.  Extra) true 0% PWM  Sometimes you might want to go lower than 30% or even turn it off to save power but also to prevent noise. I did not do this as this extra step, requires a lot of effort for very little gain in my case. However should you need to do it. This can be achieved by setting the PWM duty-cycle to 0% in the case when water temperature is already below what you like, in my code 40$^\circ$C. Then you would switch off a MOSFET thus set the gate voltage to low or 0 V and when it s above  40$^\circ$C you would turn it on. The MOSFET should then connect between your black wire (anode) from your fan and the anode of your power supply.  Connections  Since the connection diagram is quite simple I do it in words. The thermistor has 2 pins (there is no polarity) and should be connected as in the voltage divider, 1 to ground and 1 to $R_1$.  Finally the PWM signal is output at pin PA8 and this should go to the PWM pin as follows,    Lastly power for the microcontroller can be supplied over the micro-USB.  The final code  #include &lt;Arduino.h&gt; #define inLED PB12 #define PWMpin PA8 #define SERIAL_PORT Serial1 #define f_PWM 25000 #define PWMstatic 30 #define SAMPLES 100  HardwareSerial Serial1(PA_10, PA_9); //Thermistor const #define T_waterpin PA7 int Vo; float Rchosen = 4582; float logR2, R2, T; float c1 = 1.133027435e-03, c2 = 2.334426745e-04, c3 = 0.9074747924e-07;  //code variables float Ttest; int PWMdynamic = 0, PWMold= 0; int  i, Vs; bool paused = 0;  //init specifics of the hardware timer and which effectively pin TIM_TypeDef *Instance = (TIM_TypeDef *)pinmap_peripheral(digitalPinToPinName(PWMpin), PinMap_PWM); uint32_t channel = STM_PIN_CHANNEL(pinmap_function(digitalPinToPinName(PWMpin), PinMap_PWM)); //Timer object init with previous intel HardwareTimer *MyTim = new HardwareTimer(Instance);   // no need to configure pin, it will be done by HardwareTimer configuration  float reading_to_temp(int number, int R1){   int temp;   R2 = R1 / (1023.0 / (float)number - 1.0);   logR2 = log(R2);   temp = (1.0 / (c1 + c2*logR2 + c3*logR2*logR2*logR2));   temp = temp - 273.15;   return temp; }  void setup() {   pinMode(inLED, OUTPUT);   digitalWrite(inLED, LOW);   MyTim-&gt;setPWM(channel, PWMpin, f_PWM, PWMstatic);            // 5 Hertz, 10% dutycycle }  void loop() {   //improve averaging of analogread by oversampling because required speed is only ~ Hz.   Vs = 0;   for(i = 0; i &lt; SAMPLES; i++){     Vs = Vs + analogRead(T_waterpin);   }   Vo = Vs / SAMPLES;   T = reading_to_temp(Vo, Rchosen);   Ttest = T;   if(Ttest &lt;=40){     PWMdynamic = 30;     //MyTim-&gt;pause();     paused = 1;   }   else if(paused){     paused = 0;     //MyTim-&gt;resume();   }   if(Ttest &gt; 40 &amp;&amp; Ttest &lt;= 60){     PWMdynamic = 30 + 25 * (Ttest - 40) / 20;   }   else if(Ttest &gt; 60 &amp;&amp; Ttest &lt;= 70){     PWMdynamic = 55 + 45 * (Ttest - 60) / 10;   }   else if(Ttest &gt; 70){     PWMdynamic = 100;   }   //hysteresis to keep number of updates small and prevent oscillatory behaviour.   if( abs(PWMdynamic - PWMold) &gt; 3){     MyTim-&gt;setCaptureCompare(channel, PWMdynamic, PERCENT_COMPARE_FORMAT);     PWMold = PWMdynamic;   } }   Final cost                 Component       Cost ($\euro$)                       Resistor 4k7       0.01/free                 Black pill (STM32F1)       3.63           Any other STM32 series MCU would work as long as it is supported by the library. It seems my version of black pill is end of life, the new version would work also. Please be careful for the pin assignment, which could be different.">
  <meta name="twitter:url" content="https://shiko.nl/electronics/pwm-fan-controller/">

  
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://raw.githubusercontent.com/shikon/cloudimg/master/typora/photo_2021-08-27_16-51-22.jpg">
  

  



  <meta property="article:published_time" content="2021-08-27T00:00:00-04:00">





  

  


<link rel="canonical" href="https://shiko.nl/electronics/pwm-fan-controller/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Lan Hu",
      "url": "https://shiko.nl/",
      "sameAs": ["https://twitter.com/mmistakes","https://www.facebook.com/michaelrose"]
    
  }
</script>


  <meta name="google-site-verification" content="UQj93ERU9zgECodaaXgVpkjrFn9UrDMEzVamacSoQ8Y" />





<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Shiko Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Shiko
          <span class="site-subtitle">Life is an unique journey</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/about/">About</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/">Categories</a>
            </li><li class="masthead__menu-item">
              <a href="/year-archive/">Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/">Tags</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      
  







<div class="page__hero"
  style=" background-image: url('');"
>
  
    <img src="https://raw.githubusercontent.com/shikon/cloudimg/master/typora/photo_2021-08-27_16-51-22.jpg" alt="Creating a simple and cheap fan controller" class="page__hero-image">
  
  
</div>





<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="/assets/images/me.jpg" alt="Lan Hu" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Lan Hu</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>A student of life, multi-faceted, tries to master his trades.</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Noord-Brabant, NL</span>
        </li>
      

      
        
          
            <li><a href="mailto:lan@shiko.nl" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Email</span></a></li>
          
        
          
            <li><a href="https://github.com/shikon" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
          
            <li><a href="https://www.linkedin.com/in/lanhu" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span class="label">Linkedin</span></a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Creating a simple and cheap fan controller">
    <meta itemprop="description" content="From need to idea to solutionAfter upgrading my computer with the new Ryzen 5800x series, the new motherboard did not include a header to connect my water temperature sensor. This lead the control of my fans to be limited to the temperature sensor inside the processor. This would be okay if I used regular processor cooling, which has  a small thermal mass and has good thermal conductivity.  However, in my case I have a water cooling where the temperature of the radiator depends on the water temperature and not so much on the current processor temperature. There is a huge delay in the order of minutes before the water heats up due to the large thermal mass it presents. Therefore the control that acts on the same timescale as workload increases (seconds) is an ill fit. Therefore I used the water temperature, which was read out on the previous motherboard. Unfortunately the motherboard that I got on sale did not have this.Fortunately fans can easily be controlled by PWM hence this article will guide you to create a very simple and cheap PWM fan controller. But first what is PWM?Pulse-Width Modulation (PWM) for fansIn order to control the fans the motherboard sends out signals that determine the speed fans should run at. The main reason to reduce the fan speed is to reduce the noise it makes. The lower speed is okay as under low processor load, the amount of heat that should be dissipated is low.PWM is a signal and a way of communication which tells the fan at what speed it should run at. It is a digital signal and has a high (on) and low (off) level as shown here.The frequency (f) of the PWM signal depends on the total time ($T_{on}+T_{off}$),\(f = \frac{1}{T_{on}+T_{off}}.\) The speed of fan in percentage depends directly on the duty cycle (DT) in percentage,\(\mathrm{DT}=\frac{T_{on}}{T_{on}+T_{off}}.\)so if DT is 0.6 or 60% the speed of the fan will be 60% of its maximum speed.Temperature of a thermistorOkay we know how to create the signal but how do we know what speed the fans should run at. Depending on the amount of noise you allow at a certain water temperature, the water temperature is key. In order to find this out we need to translate the resistance of a thermistor back to a temperature. Typically these have a negative temperature coefficient, meaning the resistance decreases as the temperature increases. Since I do not know the model or make of my thermistor, I hoped  a commonly used model would be a good fit. The temperature ($T$) as function of the resistance ($R_T$) according to the Steinhart-Hart equation. \(\frac{1}{T}=C_1+C_2\ln{R_T}+C_3(\ln{R_T})^3\)The other option was the $\beta-$equation which is an exponential relationship and can be extended to the Steinhart-Hart equation.Requirements for the PWM fan controller  The PWM frequency of computer fans is typically 25 kHz but please check the data sheet.  Read temperature from a thermistor  The speed range for my fans was 30-100%Tackling each problem 1-by-1I separated the core functionalities of the fan controller into 3 parts.1) Microprocessor choice and coding a PWM signalIn the beginning of this year I programmed a variable duty cycle on a Arduino nano. Achieving a PWM frequency of 1 MHz is not possible with the built in PWM functionality and neither is it variable at the resolution that I wanted (8-bit). In order to do this I went down one-level and set the registers of the timers. However, my past experience learnt me this took quite some development time. Therefore, this time I opted to use a different microcontroller where I could just use higher-level functions and generate the PWM signal according to my needs as simple as a few lines of code. I found a STM32F103C8T6 (STM32 black pill) lying around in my closet and found this library that had everything I needed.2) Temperature readout by voltage dividerJust like in one of my past articles I used a voltage divider to find the thermistor resistance. Putting $R_T$ at the position of $R_2$, it can be found from the output voltage as,\(R_T = \frac{R_1}{V_{out}}\)With $R_1$ a chosen resistance in my case 4.7 k$\Omega$. Since the thermistor model is basically a linearization that is accurate in a certain range, I chose $R_1$  such that it is similar to $R_T$ during computer idle.In order to find the coefficients you would take measurements of $R_T$ at for example three different temperatures. Since my sensor was already mounted in the system and it doesn’t have to be very accurate I took a random measurement found on the internet for the same kind of thermistor that I had which is a 10 k$\Omega$-thermistor. Plugged 3-points into this tool for 25, 50 and 70 $^\circ$ C, which is the range I expect the water to be in and thus the sensor to be exposed to.3) Defining different speed ramp up ranged depending on temperatureIn order to create a silent system you want initially the fan speed to be low at low temperatures and high at high temperature. But what is low and and what is high? Since my fans can not be run below 30%, this was the lower limit (this is not exactly true but I will discuss this later). In order for heat transfer to occur via convection there needs to be a temperature difference between the radiator ( I assume it equal to it water temperature) and the environment. My room is typically below  30$^\circ$C therefore up to let say a water temperature of 40$^\circ$C the fans run in the lowest setting and then they should gradually increase. This is in my code split into 2 different ramps, in order to keep the system more quiet and when a lot of heat is dumped into the water cooling, the fans will still go to 100%. This point was chosen to be 70$^\circ$C, because the tubes start to melt at 74$^\circ$C according to the manufacturer.Extra) true 0% PWMSometimes you might want to go lower than 30% or even turn it off to save power but also to prevent noise. I did not do this as this extra step, requires a lot of effort for very little gain in my case. However should you need to do it. This can be achieved by setting the PWM duty-cycle to 0% in the case when water temperature is already below what you like, in my code 40$^\circ$C. Then you would switch off a MOSFET thus set the gate voltage to low or 0 V and when it s above  40$^\circ$C you would turn it on. The MOSFET should then connect between your black wire (anode) from your fan and the anode of your power supply.ConnectionsSince the connection diagram is quite simple I do it in words. The thermistor has 2 pins (there is no polarity) and should be connected as in the voltage divider, 1 to ground and 1 to $R_1$.  Finally the PWM signal is output at pin PA8 and this should go to the PWM pin as follows,Lastly power for the microcontroller can be supplied over the micro-USB.The final code#include &lt;Arduino.h&gt;#define inLED PB12#define PWMpin PA8#define SERIAL_PORT Serial1#define f_PWM 25000#define PWMstatic 30#define SAMPLES 100HardwareSerial Serial1(PA_10, PA_9);//Thermistor const#define T_waterpin PA7int Vo;float Rchosen = 4582;float logR2, R2, T;float c1 = 1.133027435e-03, c2 = 2.334426745e-04, c3 = 0.9074747924e-07;//code variablesfloat Ttest;int PWMdynamic = 0, PWMold= 0;int  i, Vs;bool paused = 0;//init specifics of the hardware timer and which effectively pinTIM_TypeDef *Instance = (TIM_TypeDef *)pinmap_peripheral(digitalPinToPinName(PWMpin), PinMap_PWM);uint32_t channel = STM_PIN_CHANNEL(pinmap_function(digitalPinToPinName(PWMpin), PinMap_PWM));//Timer object init with previous intelHardwareTimer *MyTim = new HardwareTimer(Instance);   // no need to configure pin, it will be done by HardwareTimer configurationfloat reading_to_temp(int number, int R1){  int temp;  R2 = R1 / (1023.0 / (float)number - 1.0);  logR2 = log(R2);  temp = (1.0 / (c1 + c2*logR2 + c3*logR2*logR2*logR2));  temp = temp - 273.15;  return temp;}void setup() {  pinMode(inLED, OUTPUT);  digitalWrite(inLED, LOW);  MyTim-&gt;setPWM(channel, PWMpin, f_PWM, PWMstatic);            // 5 Hertz, 10% dutycycle}void loop() {  //improve averaging of analogread by oversampling because required speed is only ~ Hz.  Vs = 0;  for(i = 0; i &lt; SAMPLES; i++){    Vs = Vs + analogRead(T_waterpin);  }  Vo = Vs / SAMPLES;  T = reading_to_temp(Vo, Rchosen);  Ttest = T;  if(Ttest &lt;=40){    PWMdynamic = 30;    //MyTim-&gt;pause();    paused = 1;  }  else if(paused){    paused = 0;    //MyTim-&gt;resume();  }  if(Ttest &gt; 40 &amp;&amp; Ttest &lt;= 60){    PWMdynamic = 30 + 25 * (Ttest - 40) / 20;  }  else if(Ttest &gt; 60 &amp;&amp; Ttest &lt;= 70){    PWMdynamic = 55 + 45 * (Ttest - 60) / 10;  }  else if(Ttest &gt; 70){    PWMdynamic = 100;  }  //hysteresis to keep number of updates small and prevent oscillatory behaviour.  if( abs(PWMdynamic - PWMold) &gt; 3){    MyTim-&gt;setCaptureCompare(channel, PWMdynamic, PERCENT_COMPARE_FORMAT);    PWMold = PWMdynamic;  }}Final cost            Component      Cost ($\euro$)                  Resistor 4k7      0.01/free              Black pill (STM32F1)      3.63      Any other STM32 series MCU would work as long as it is supported by the library. It seems my version of black pill is end of life, the new version would work also. Please be careful for the pin assignment, which could be different.">
    <meta itemprop="datePublished" content="2021-08-27T00:00:00-04:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Creating a simple and cheap fan controller
</h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          10 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu">
  <li><a href="#from-need-to-idea-to-solution">From need to idea to solution</a></li>
  <li><a href="#pulse-width-modulation-pwm-for-fans">Pulse-Width Modulation (PWM) for fans</a></li>
  <li><a href="#temperature-of-a-thermistor">Temperature of a thermistor</a></li>
  <li><a href="#requirements-for-the-pwm-fan-controller">Requirements for the PWM fan controller</a></li>
  <li><a href="#tackling-each-problem-1-by-1">Tackling each problem 1-by-1</a>
    <ul>
      <li><a href="#1-microprocessor-choice-and-coding-a-pwm-signal">1) Microprocessor choice and coding a PWM signal</a></li>
      <li><a href="#2-temperature-readout-by-voltage-divider">2) Temperature readout by voltage divider</a></li>
      <li><a href="#3-defining-different-speed-ramp-up-ranged-depending-on-temperature">3) Defining different speed ramp up ranged depending on temperature</a></li>
      <li><a href="#extra-true-0-pwm">Extra) true 0% PWM</a></li>
    </ul>
  </li>
  <li><a href="#connections">Connections</a></li>
  <li><a href="#the-final-code">The final code</a></li>
  <li><a href="#final-cost">Final cost</a></li>
</ul>

            </nav>
          </aside>
        
        <h1 id="from-need-to-idea-to-solution">From need to idea to solution</h1>

<p>After upgrading my computer with the new Ryzen 5800x series, the new motherboard did not include a header to connect my water temperature sensor. This lead the control of my fans to be limited to the temperature sensor inside the processor. This would be okay if I used regular processor cooling, which has  a small thermal mass and has good thermal conductivity.  However, in my case I have a water cooling where the temperature of the radiator depends on the water temperature and not so much on the current processor temperature. There is a huge delay in the order of minutes before the water heats up due to the large thermal mass it presents. Therefore the control that acts on the same timescale as workload increases (seconds) is an ill fit. Therefore I used the water temperature, which was read out on the previous motherboard. Unfortunately the motherboard that I got on sale did not have this.</p>

<p>Fortunately fans can easily be controlled by PWM hence this article will guide you to create a very simple and cheap PWM fan controller. But first what is PWM?</p>

<h1 id="pulse-width-modulation-pwm-for-fans">Pulse-Width Modulation (PWM) for fans</h1>

<p>In order to control the fans the motherboard sends out signals that determine the speed fans should run at. The main reason to reduce the fan speed is to reduce the noise it makes. The lower speed is okay as under low processor load, the amount of heat that should be dissipated is low.</p>

<p>PWM is a signal and a way of communication which tells the fan at what speed it should run at. It is a digital signal and has a high (on) and low (off) level as shown here.</p>

<p><img src="https://raw.githubusercontent.com/shikon/cloudimg/master/typora/4j9UsPWYo5hWc5Y_U_FWimTo1gUOLgLpfqF3OEmYQeDe3wfz6i_qOSvNcTggeu2RuCE46kZcDA" alt="Taken from Bvsystems.be" /></p>

<p>The frequency (f) of the PWM signal depends on the total time ($T_{on}+T_{off}$),
\(f = \frac{1}{T_{on}+T_{off}}.\)
 The speed of fan in percentage depends directly on the duty cycle (DT) in percentage,
\(\mathrm{DT}=\frac{T_{on}}{T_{on}+T_{off}}.\)
so if DT is 0.6 or 60% the speed of the fan will be 60% of its maximum speed.</p>

<h1 id="temperature-of-a-thermistor">Temperature of a thermistor</h1>

<p>Okay we know how to create the signal but how do we know what speed the fans should run at. Depending on the amount of noise you allow at a certain water temperature, the water temperature is key. In order to find this out we need to translate the resistance of a thermistor back to a temperature. Typically these have a negative temperature coefficient, meaning the resistance decreases as the temperature increases. Since I do not know the model or make of my thermistor, I hoped  a commonly used model would be a good fit. The temperature ($T$) as function of the resistance ($R_T$) according to the Steinhart-Hart equation. 
\(\frac{1}{T}=C_1+C_2\ln{R_T}+C_3(\ln{R_T})^3\)
The other option was the <a href="https://en.wikipedia.org/wiki/Thermistor#B_or_%CE%B2_parameter_equation">$\beta-$equation</a> which is an exponential relationship and can be extended to the Steinhart-Hart equation.</p>

<h1 id="requirements-for-the-pwm-fan-controller">Requirements for the PWM fan controller</h1>

<ol>
  <li>The PWM frequency of computer fans is typically 25 kHz but please check the data sheet.</li>
  <li>Read temperature from a thermistor</li>
  <li>The speed range for my fans was 30-100%</li>
</ol>

<h1 id="tackling-each-problem-1-by-1">Tackling each problem 1-by-1</h1>

<p>I separated the core functionalities of the fan controller into 3 parts.</p>

<h2 id="1-microprocessor-choice-and-coding-a-pwm-signal">1) Microprocessor choice and coding a PWM signal</h2>

<p>In the beginning of this year I programmed a variable duty cycle on a Arduino nano. Achieving a PWM frequency of 1 MHz is not possible with the built in PWM functionality and neither is it variable at the resolution that I wanted (8-bit). In order to do this I went down one-level and set the registers of the timers. However, my past experience learnt me this took quite some development time. Therefore, this time I opted to use a different microcontroller where I could just use higher-level functions and generate the PWM signal according to my needs as simple as a few lines of code. I found a STM32F103C8T6 (STM32 black pill) lying around in my closet and found <a href="https://github.com/stm32duino/wiki/wiki/HardwareTimer-library">this library</a> that had everything I needed.</p>

<h2 id="2-temperature-readout-by-voltage-divider">2) Temperature readout by voltage divider</h2>

<p>Just like in one of my <a href="https://shiko.nl/electronics/a-pcb-design/#working-principle-of-smps">past articles</a> I used a voltage divider to find the thermistor resistance. Putting $R_T$ at the position of $R_2$, it can be found from the output voltage as,
\(R_T = \frac{R_1}{V_{out}}\)
With $R_1$ a chosen resistance in my case 4.7 k$\Omega$. Since the thermistor model is basically a linearization that is accurate in a certain range, I chose $R_1$  such that it is similar to $R_T$ during computer idle.</p>

<p>In order to find the coefficients you would take measurements of $R_T$ at for example three different temperatures. Since my sensor was already mounted in the system and it doesn’t have to be very accurate I took a <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;ved=2ahUKEwi6qprQsNHyAhUFmFwKHeLEAGgQFnoECB8QAQ&amp;url=http%3A%2F%2Fwww.bapihvac.com%2Fwp-content%2Fuploads%2F2010%2F11%2FThermistor_10K-2.pdf&amp;usg=AOvVaw0w8p8u6Bg9c-7rXmQ3OiK7">random</a> measurement found on the internet for the same kind of thermistor that I had which is a 10 k$\Omega$-thermistor. Plugged 3-points into <a href="https://www.thinksrs.com/downloads/programs/therm%20calc/ntccalibrator/ntccalculator.html">this</a> tool for 25, 50 and 70 $^\circ$ C, which is the range I expect the water to be in and thus the sensor to be exposed to.</p>

<h2 id="3-defining-different-speed-ramp-up-ranged-depending-on-temperature">3) Defining different speed ramp up ranged depending on temperature</h2>

<p>In order to create a silent system you want initially the fan speed to be low at low temperatures and high at high temperature. But what is low and and what is high? Since my fans can not be run below 30%, this was the lower limit (this is not exactly true but I will discuss this later). In order for heat transfer to occur via convection there needs to be a temperature difference between the radiator ( I assume it equal to it water temperature) and the environment. My room is typically below  30$^\circ$C therefore up to let say a water temperature of 40$^\circ$C the fans run in the lowest setting and then they should gradually increase. This is in my code split into 2 different ramps, in order to keep the system more quiet and when a lot of heat is dumped into the water cooling, the fans will still go to 100%. This point was chosen to be 70$^\circ$C, because the tubes start to melt at 74$^\circ$C according to the manufacturer.</p>

<h2 id="extra-true-0-pwm">Extra) true 0% PWM</h2>

<p>Sometimes you might want to go lower than 30% or even turn it off to save power but also to prevent noise. I did not do this as this extra step, requires a lot of effort for very little gain in my case. However should you need to do it. This can be achieved by setting the PWM duty-cycle to 0% in the case when water temperature is already below what you like, in my code 40$^\circ$C. Then you would switch off a MOSFET thus set the gate voltage to low or 0 V and when it s above  40$^\circ$C you would turn it on. The MOSFET should then connect between your black wire (anode) from your fan and the anode of your power supply.</p>

<h1 id="connections">Connections</h1>

<p>Since the connection diagram is quite simple I do it in words. The thermistor has 2 pins (there is no polarity) and should be connected as in the voltage divider, 1 to ground and 1 to $R_1$.  Finally the PWM signal is output at pin PA8 and this should go to the PWM pin as follows,</p>

<p><img src="https://raw.githubusercontent.com/shikon/cloudimg/master/typora/02-1.jpg" alt="From ekwb.com" /></p>

<p>Lastly power for the microcontroller can be supplied over the micro-USB.</p>

<h1 id="the-final-code">The final code</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;Arduino.h&gt;
#define inLED PB12
#define PWMpin PA8
#define SERIAL_PORT Serial1
#define f_PWM 25000
#define PWMstatic 30
#define SAMPLES 100

HardwareSerial Serial1(PA_10, PA_9);
//Thermistor const
#define T_waterpin PA7
int Vo;
float Rchosen = 4582;
float logR2, R2, T;
float c1 = 1.133027435e-03, c2 = 2.334426745e-04, c3 = 0.9074747924e-07;

//code variables
float Ttest;
int PWMdynamic = 0, PWMold= 0;
int  i, Vs;
bool paused = 0;

//init specifics of the hardware timer and which effectively pin
TIM_TypeDef *Instance = (TIM_TypeDef *)pinmap_peripheral(digitalPinToPinName(PWMpin), PinMap_PWM);
uint32_t channel = STM_PIN_CHANNEL(pinmap_function(digitalPinToPinName(PWMpin), PinMap_PWM));
//Timer object init with previous intel
HardwareTimer *MyTim = new HardwareTimer(Instance);   // no need to configure pin, it will be done by HardwareTimer configuration

float reading_to_temp(int number, int R1){
  int temp;
  R2 = R1 / (1023.0 / (float)number - 1.0);
  logR2 = log(R2);
  temp = (1.0 / (c1 + c2*logR2 + c3*logR2*logR2*logR2));
  temp = temp - 273.15;
  return temp;
}

void setup() {
  pinMode(inLED, OUTPUT);
  digitalWrite(inLED, LOW);
  MyTim-&gt;setPWM(channel, PWMpin, f_PWM, PWMstatic);            // 5 Hertz, 10% dutycycle
}

void loop() {
  //improve averaging of analogread by oversampling because required speed is only ~ Hz.
  Vs = 0;
  for(i = 0; i &lt; SAMPLES; i++){
    Vs = Vs + analogRead(T_waterpin);
  }
  Vo = Vs / SAMPLES;
  T = reading_to_temp(Vo, Rchosen);
  Ttest = T;
  if(Ttest &lt;=40){
    PWMdynamic = 30;
    //MyTim-&gt;pause();
    paused = 1;
  }
  else if(paused){
    paused = 0;
    //MyTim-&gt;resume();
  }
  if(Ttest &gt; 40 &amp;&amp; Ttest &lt;= 60){
    PWMdynamic = 30 + 25 * (Ttest - 40) / 20;
  }
  else if(Ttest &gt; 60 &amp;&amp; Ttest &lt;= 70){
    PWMdynamic = 55 + 45 * (Ttest - 60) / 10;
  }
  else if(Ttest &gt; 70){
    PWMdynamic = 100;
  }
  //hysteresis to keep number of updates small and prevent oscillatory behaviour.
  if( abs(PWMdynamic - PWMold) &gt; 3){
    MyTim-&gt;setCaptureCompare(channel, PWMdynamic, PERCENT_COMPARE_FORMAT);
    PWMold = PWMdynamic;
  }
}
</code></pre></div></div>

<h1 id="final-cost">Final cost</h1>

<table>
  <thead>
    <tr>
      <th>Component</th>
      <th>Cost ($\euro$)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Resistor 4k7</td>
      <td>0.01/free</td>
    </tr>
    <tr>
      <td>Black pill (STM32F1)</td>
      <td><a href="https://www.aliexpress.com/item/1005003127544969.html?spm=a2g0o.productlist.0.0.4c7e206063NLMD&amp;algo_pvid=0c396bde-c6ff-4e7c-a00f-647e6da82627&amp;algo_exp_id=0c396bde-c6ff-4e7c-a00f-647e6da82627-0">3.63</a></td>
    </tr>
  </tbody>
</table>

<p>Any other STM32 series MCU would work as long as it is supported by the library. It seems my version of black pill is end of life, the new version would work also. Please be careful for the pin assignment, which could be different.</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#design" class="page__taxonomy-item" rel="tag">design</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#pcb" class="page__taxonomy-item" rel="tag">PCB</a>
    
    </span>
  </p>




  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/#electronics" class="page__taxonomy-item" rel="tag">electronics</a>
    
    </span>
  </p>


        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2021-08-27T00:00:00-04:00">August 27, 2021</time></p>


      </footer>

      <section class="page__share">
  

  <a href="https://twitter.com/intent/tweet?via=mmistakes&text=Creating+a+simple+and+cheap+fan+controller%20https%3A%2F%2Fshiko.nl%2Felectronics%2Fpwm-fan-controller%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fshiko.nl%2Felectronics%2Fpwm-fan-controller%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fshiko.nl%2Felectronics%2Fpwm-fan-controller%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/electronics/designing_business_card/" class="pagination--pager" title="Creating a custom PCB business card with EAGLE
">Previous</a>
    
    
      <a href="#" class="pagination--pager disabled">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You May Also Enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/electronics/designing_business_card/" rel="permalink">Creating a custom PCB business card with EAGLE
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          6 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">An idea

I have looked into making my own business cards multiple times. They would be useful to carry with you just in case. However I never came up with so...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/programming/automating_jekyll/" rel="permalink">Automating jekyll build and github hosting
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          5 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Backstory

As people might have noticed this website runs on jekyll, which is code that creates static websites. Great for my simple blogging use. The easies...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/electronics/a-pcb-design/" rel="permalink">Designing a Nixie HV supply part 1
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          7 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Backstory

Well basically the backstory is the introduction but shht :). Recently I designed a small PCB with an analog switch for my internship project. Thi...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/3d-printing/drawing-orings/" rel="permalink">Drawing O-rings for dad aka printing O-rings for dad part 2
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          4 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Practicalities…

While waiting for my Sainsmart 3D TPU filament to arrive, I still needed some other parts before I could start the printing. That is a CAD d...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><div class="search-searchbar"></div>
  <div class="search-hits"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-instagram" aria-hidden="true"></i> Instagram</a></li>
        
      
    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2021 Lan Hu. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>


<!-- Including InstantSearch.js library and styling -->
<script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.3.3/dist/instantsearch.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.3.3/dist/instantsearch.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.3.3/dist/instantsearch-theme-algolia.min.css">

<script>
// Instanciating InstantSearch.js with Algolia credentials
const search = instantsearch({
  appId: 'L6XIHWOGZ2',
  apiKey: '43db23cbf486a7a95d34883d3391bdab',
  indexName: 'blog',
  searchParameters: {
    restrictSearchableAttributes: [
      'title',
      'content'
    ]
  }
});

const hitTemplate = function(hit) {
  const url = hit.url;
  const title = hit._highlightResult.title.value;
  const content = hit._highlightResult.html.value;

  return `
    <div class="list__item">
      <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
        <h2 class="archive__item-title" itemprop="headline"><a href="/${url}">${title}</a></h2>
        <div class="archive__item-excerpt" itemprop="description">${content}</div>
      </article>
    </div>
  `;
}

// Adding searchbar and results widgets
search.addWidget(
  instantsearch.widgets.searchBox({
    container: '.search-searchbar',
    poweredBy: true,
    placeholder: 'Enter your search term...'
  })
);
search.addWidget(
  instantsearch.widgets.hits({
    container: '.search-hits',
    templates: {
      item: hitTemplate,
      empty: 'No results',
    }
  })
);

// Starting the search only when toggle is clicked
$(document).ready(function () {
  $(".search__toggle").on("click", function() {
    if(!search.started) {
      search.start();
    }
  });
});
</script>









<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" defer
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>


  </body>
</html>
